{"ast":null,"code":"import React, { useMemo, useRef, useEffect, useState, useContext } from 'react';\nimport { useDndContext, getBoundingClientRect, useDroppable, useDraggable, getViewRect, closestCorners, getScrollableAncestors, KeyboardCode } from '@dnd-kit/core';\nimport { useUniqueId, useIsomorphicLayoutEffect, CSS, useCombinedRefs } from '@dnd-kit/utilities';\n\n/**\r\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\r\n */\nfunction arrayMove(array, from, to) {\n  const newArray = array.slice();\n  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);\n  return newArray;\n}\nfunction getSortedRects(items, layoutRects) {\n  return items.reduce((accumulator, id, index) => {\n    const layoutRect = layoutRects.get(id);\n    if (layoutRect) {\n      accumulator[index] = layoutRect;\n    }\n    return accumulator;\n  }, Array(items.length));\n}\nfunction isValidIndex(index) {\n  return index !== null && index >= 0;\n}\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1\n};\nconst horizontalListSortingStrategy = ({\n  layoutRects,\n  activeNodeRect: fallbackActiveRect,\n  activeIndex,\n  overIndex,\n  index\n}) => {\n  var _layoutRects$activeIn;\n  const activeNodeRect = (_layoutRects$activeIn = layoutRects[activeIndex]) != null ? _layoutRects$activeIn : fallbackActiveRect;\n  if (!activeNodeRect) {\n    return null;\n  }\n  const itemGap = getItemGap(layoutRects, index, activeIndex);\n  if (index === activeIndex) {\n    const newIndexRect = layoutRects[overIndex];\n    if (!newIndexRect) {\n      return null;\n    }\n    return {\n      x: activeIndex < overIndex ? newIndexRect.offsetLeft + newIndexRect.width - (activeNodeRect.offsetLeft + activeNodeRect.width) : newIndexRect.offsetLeft - activeNodeRect.offsetLeft,\n      y: 0,\n      ...defaultScale\n    };\n  }\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: -activeNodeRect.width - itemGap,\n      y: 0,\n      ...defaultScale\n    };\n  }\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: activeNodeRect.width + itemGap,\n      y: 0,\n      ...defaultScale\n    };\n  }\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale\n  };\n};\nfunction getItemGap(layoutRects, index, activeIndex) {\n  const currentRect = layoutRects[index];\n  const previousRect = layoutRects[index - 1];\n  const nextRect = layoutRects[index + 1];\n  if (!previousRect && !nextRect) {\n    return 0;\n  }\n  if (activeIndex < index) {\n    return previousRect ? currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width) : nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width);\n  }\n  return nextRect ? nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width) : currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width);\n}\nconst rectSortingStrategy = ({\n  layoutRects,\n  activeIndex,\n  overIndex,\n  index\n}) => {\n  const newRects = arrayMove(layoutRects, overIndex, activeIndex);\n  const oldRect = layoutRects[index];\n  const newRect = newRects[index];\n  if (!newRect || !oldRect) {\n    return null;\n  }\n  return {\n    x: newRect.offsetLeft - oldRect.offsetLeft,\n    y: newRect.offsetTop - oldRect.offsetTop,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height\n  };\n};\nconst rectSwappingStrategy = ({\n  activeIndex,\n  index,\n  layoutRects,\n  overIndex\n}) => {\n  let oldRect;\n  let newRect;\n  if (index === activeIndex) {\n    oldRect = layoutRects[index];\n    newRect = layoutRects[overIndex];\n  }\n  if (index === overIndex) {\n    oldRect = layoutRects[index];\n    newRect = layoutRects[activeIndex];\n  }\n  if (!newRect || !oldRect) {\n    return null;\n  }\n  return {\n    x: newRect.offsetLeft - oldRect.offsetLeft,\n    y: newRect.offsetTop - oldRect.offsetTop,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height\n  };\n};\n\n// To-do: We should be calculating scale transformation\nconst defaultScale$1 = {\n  scaleX: 1,\n  scaleY: 1\n};\nconst verticalListSortingStrategy = ({\n  activeIndex,\n  activeNodeRect: fallbackActiveRect,\n  index,\n  layoutRects,\n  overIndex\n}) => {\n  var _layoutRects$activeIn;\n  const activeNodeRect = (_layoutRects$activeIn = layoutRects[activeIndex]) != null ? _layoutRects$activeIn : fallbackActiveRect;\n  if (!activeNodeRect) {\n    return null;\n  }\n  if (index === activeIndex) {\n    const overIndexRect = layoutRects[overIndex];\n    if (!overIndexRect) {\n      return null;\n    }\n    return {\n      x: 0,\n      y: activeIndex < overIndex ? overIndexRect.offsetTop + overIndexRect.height - (activeNodeRect.offsetTop + activeNodeRect.height) : overIndexRect.offsetTop - activeNodeRect.offsetTop,\n      ...defaultScale$1\n    };\n  }\n  const itemGap = getItemGap$1(layoutRects, index, activeIndex);\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: 0,\n      y: -activeNodeRect.height - itemGap,\n      ...defaultScale$1\n    };\n  }\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: 0,\n      y: activeNodeRect.height + itemGap,\n      ...defaultScale$1\n    };\n  }\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale$1\n  };\n};\nfunction getItemGap$1(layoutRects, index, activeIndex) {\n  const currentRect = layoutRects[index];\n  const previousRect = layoutRects[index - 1];\n  const nextRect = layoutRects[index + 1];\n  if (!currentRect) {\n    return 0;\n  }\n  if (activeIndex < index) {\n    return previousRect ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height) : nextRect ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height) : 0;\n  }\n  return nextRect ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height) : previousRect ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height) : 0;\n}\nconst ID_PREFIX = 'Sortable';\nconst Context = /*#__PURE__*/React.createContext({\n  activeIndex: -1,\n  containerId: ID_PREFIX,\n  disableTransforms: false,\n  items: [],\n  overIndex: -1,\n  useDragOverlay: false,\n  sortedRects: [],\n  strategy: rectSortingStrategy,\n  wasSorting: {\n    current: false\n  }\n});\nfunction SortableContext({\n  children,\n  id,\n  items: userDefinedItems,\n  strategy = rectSortingStrategy\n}) {\n  const {\n    active,\n    overlayNode,\n    droppableRects,\n    over,\n    recomputeLayouts,\n    willRecomputeLayouts\n  } = useDndContext();\n  const containerId = useUniqueId(ID_PREFIX, id);\n  const useDragOverlay = Boolean(overlayNode.rect !== null);\n  const items = useMemo(() => userDefinedItems.map(item => typeof item === 'string' ? item : item.id), [userDefinedItems]);\n  const activeIndex = active ? items.indexOf(active.id) : -1;\n  const isSorting = activeIndex !== -1;\n  const wasSorting = useRef(isSorting);\n  const overIndex = over ? items.indexOf(over.id) : -1;\n  const previousItemsRef = useRef(items);\n  const sortedRects = getSortedRects(items, droppableRects);\n  const itemsHaveChanged = !isEqual(items, previousItemsRef.current);\n  const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;\n  useIsomorphicLayoutEffect(() => {\n    if (itemsHaveChanged && isSorting && !willRecomputeLayouts) {\n      // To-do: Add partial recompution of only subset of rects\n      recomputeLayouts();\n    }\n  }, [itemsHaveChanged, isSorting, recomputeLayouts, willRecomputeLayouts]);\n  useEffect(() => {\n    previousItemsRef.current = items;\n  }, [items]);\n  useEffect(() => {\n    requestAnimationFrame(() => {\n      wasSorting.current = isSorting;\n    });\n  }, [isSorting]);\n  const contextValue = useMemo(() => ({\n    activeIndex,\n    containerId,\n    disableTransforms,\n    items,\n    overIndex,\n    useDragOverlay,\n    sortedRects,\n    strategy,\n    wasSorting\n  }), [activeIndex, containerId, disableTransforms, items, overIndex, sortedRects, useDragOverlay, strategy, wasSorting]);\n  return React.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\nfunction isEqual(arr1, arr2) {\n  return arr1.join() === arr2.join();\n}\nconst defaultAnimateLayoutChanges = ({\n  isSorting,\n  index,\n  newIndex,\n  transition\n}) => {\n  if (!transition) {\n    return false;\n  }\n  if (isSorting) {\n    return true;\n  }\n  return newIndex !== index;\n};\nconst defaultTransition = {\n  duration: 200,\n  easing: 'ease'\n};\nconst transitionProperty = 'transform';\nconst disabledTransition = /*#__PURE__*/CSS.Transition.toString({\n  property: transitionProperty,\n  duration: 0,\n  easing: 'linear'\n});\nconst defaultAttributes = {\n  roleDescription: 'sortable'\n};\n\n/*\r\n * When the index of an item changes while sorting,\r\n * we need to temporarily disable the transforms\r\n */\n\nfunction useDerivedTransform({\n  rect,\n  disabled,\n  index,\n  node\n}) {\n  const [derivedTransform, setDerivedtransform] = useState(null);\n  const prevIndex = useRef(index);\n  useEffect(() => {\n    if (!disabled && index !== prevIndex.current && node.current) {\n      const initial = rect.current;\n      if (initial) {\n        const current = getBoundingClientRect(node.current);\n        const delta = {\n          x: initial.offsetLeft - current.offsetLeft,\n          y: initial.offsetTop - current.offsetTop,\n          scaleX: initial.width / current.width,\n          scaleY: initial.height / current.height\n        };\n        if (delta.x || delta.y) {\n          setDerivedtransform(delta);\n        }\n      }\n    }\n    if (index !== prevIndex.current) {\n      prevIndex.current = index;\n    }\n  }, [disabled, index, node, rect]);\n  useEffect(() => {\n    if (derivedTransform) {\n      requestAnimationFrame(() => {\n        setDerivedtransform(null);\n      });\n    }\n  }, [derivedTransform]);\n  return derivedTransform;\n}\nfunction useSortable({\n  animateLayoutChanges = defaultAnimateLayoutChanges,\n  attributes: userDefinedAttributes,\n  disabled,\n  data: customData,\n  id,\n  strategy: localStrategy,\n  transition = defaultTransition\n}) {\n  const {\n    items,\n    containerId,\n    activeIndex,\n    disableTransforms,\n    sortedRects,\n    overIndex,\n    useDragOverlay,\n    strategy: globalStrategy,\n    wasSorting\n  } = useContext(Context);\n  const index = items.indexOf(id);\n  const data = useMemo(() => ({\n    sortable: {\n      containerId,\n      index,\n      items\n    },\n    ...customData\n  }), [containerId, customData, index, items]);\n  const {\n    rect,\n    node,\n    setNodeRef: setDroppableNodeRef\n  } = useDroppable({\n    id,\n    data\n  });\n  const {\n    active,\n    activeNodeRect,\n    activatorEvent,\n    attributes,\n    setNodeRef: setDraggableNodeRef,\n    listeners,\n    isDragging,\n    over,\n    transform\n  } = useDraggable({\n    id,\n    data,\n    attributes: {\n      ...defaultAttributes,\n      ...userDefinedAttributes\n    },\n    disabled\n  });\n  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);\n  const isSorting = Boolean(active);\n  const displaceItem = isSorting && wasSorting.current && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);\n  const shouldDisplaceDragSource = !useDragOverlay && isDragging;\n  const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;\n  const strategy = localStrategy != null ? localStrategy : globalStrategy;\n  const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({\n    layoutRects: sortedRects,\n    activeNodeRect,\n    activeIndex,\n    overIndex,\n    index\n  }) : null;\n  const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? arrayMove(items, activeIndex, overIndex).indexOf(id) : index;\n  const prevNewIndex = useRef(newIndex);\n  const shouldAnimateLayoutChanges = animateLayoutChanges({\n    active,\n    isDragging,\n    isSorting,\n    id,\n    index,\n    items,\n    newIndex: prevNewIndex.current,\n    transition,\n    wasSorting: wasSorting.current\n  });\n  const derivedTransform = useDerivedTransform({\n    disabled: !shouldAnimateLayoutChanges,\n    index,\n    node,\n    rect\n  });\n  useEffect(() => {\n    if (isSorting) {\n      prevNewIndex.current = newIndex;\n    }\n  }, [isSorting, newIndex]);\n  return {\n    active,\n    attributes,\n    activatorEvent,\n    rect,\n    index,\n    isSorting,\n    isDragging,\n    listeners,\n    node,\n    overIndex,\n    over,\n    setNodeRef,\n    setDroppableNodeRef,\n    setDraggableNodeRef,\n    transform: derivedTransform != null ? derivedTransform : finalTransform,\n    transition: getTransition()\n  };\n  function getTransition() {\n    if (derivedTransform) {\n      // Temporarily disable transitions for a single frame to set up derived transforms\n      return disabledTransition;\n    }\n    if (shouldDisplaceDragSource || !transition) {\n      return null;\n    }\n    if (isSorting || shouldAnimateLayoutChanges) {\n      return CSS.Transition.toString({\n        ...transition,\n        property: transitionProperty\n      });\n    }\n    return null;\n  }\n}\nconst directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];\nconst sortableKeyboardCoordinates = (event, {\n  context: {\n    droppableContainers,\n    translatedRect,\n    scrollableAncestors\n  }\n}) => {\n  if (directions.includes(event.code)) {\n    event.preventDefault();\n    if (!translatedRect) {\n      return;\n    }\n    const layoutRects = [];\n    Object.entries(droppableContainers).forEach(([id, container]) => {\n      if (container == null ? void 0 : container.disabled) {\n        return;\n      }\n      const node = container == null ? void 0 : container.node.current;\n      if (!node) {\n        return;\n      }\n      const rect = getViewRect(node);\n      switch (event.code) {\n        case KeyboardCode.Down:\n          if (translatedRect.top + translatedRect.height <= rect.top) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n        case KeyboardCode.Up:\n          if (translatedRect.top >= rect.top + rect.height) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n        case KeyboardCode.Left:\n          if (translatedRect.left >= rect.left + rect.width) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n        case KeyboardCode.Right:\n          if (translatedRect.left + translatedRect.width <= rect.left) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n      }\n    });\n    const closestId = closestCorners(layoutRects, translatedRect);\n    if (closestId) {\n      var _droppableContainers$;\n      const newNode = (_droppableContainers$ = droppableContainers[closestId]) == null ? void 0 : _droppableContainers$.node.current;\n      if (newNode) {\n        const newScrollAncestors = getScrollableAncestors(newNode);\n        const hasDifferentScrollAncestors = newScrollAncestors.some((element, index) => scrollableAncestors[index] !== element);\n        const newRect = getViewRect(newNode);\n        const offset = hasDifferentScrollAncestors ? {\n          x: 0,\n          y: 0\n        } : {\n          x: translatedRect.width - newRect.width,\n          y: translatedRect.height - newRect.height\n        };\n        const newCoordinates = {\n          x: newRect.left - offset.x,\n          y: newRect.top - offset.y\n        };\n        return newCoordinates;\n      }\n    }\n  }\n  return undefined;\n};\nexport { SortableContext, arrayMove, defaultAnimateLayoutChanges, horizontalListSortingStrategy, rectSortingStrategy, rectSwappingStrategy, sortableKeyboardCoordinates, useSortable, verticalListSortingStrategy };","map":{"version":3,"names":["arrayMove","array","from","to","newArray","slice","splice","length","getSortedRects","items","layoutRects","reduce","accumulator","id","index","layoutRect","get","Array","isValidIndex","defaultScale","scaleX","scaleY","horizontalListSortingStrategy","activeNodeRect","fallbackActiveRect","activeIndex","overIndex","_layoutRects$activeIn","itemGap","getItemGap","newIndexRect","x","offsetLeft","width","y","currentRect","previousRect","nextRect","rectSortingStrategy","newRects","oldRect","newRect","offsetTop","height","rectSwappingStrategy","defaultScale$1","verticalListSortingStrategy","overIndexRect","getItemGap$1","ID_PREFIX","Context","React","createContext","containerId","disableTransforms","useDragOverlay","sortedRects","strategy","wasSorting","current","SortableContext","children","userDefinedItems","active","overlayNode","droppableRects","over","recomputeLayouts","willRecomputeLayouts","useDndContext","useUniqueId","Boolean","rect","useMemo","map","item","indexOf","isSorting","useRef","previousItemsRef","itemsHaveChanged","isEqual","useIsomorphicLayoutEffect","useEffect","requestAnimationFrame","contextValue","createElement","Provider","value","arr1","arr2","join","defaultAnimateLayoutChanges","newIndex","transition","defaultTransition","duration","easing","transitionProperty","disabledTransition","CSS","Transition","toString","property","defaultAttributes","roleDescription","useDerivedTransform","disabled","node","derivedTransform","setDerivedtransform","useState","prevIndex","initial","getBoundingClientRect","delta","useSortable","animateLayoutChanges","attributes","userDefinedAttributes","data","customData","localStrategy","globalStrategy","useContext","sortable","setNodeRef","setDroppableNodeRef","useDroppable","activatorEvent","setDraggableNodeRef","listeners","isDragging","transform","useDraggable","useCombinedRefs","displaceItem","shouldDisplaceDragSource","dragSourceDisplacement","finalTransform","prevNewIndex","shouldAnimateLayoutChanges","getTransition","directions","KeyboardCode","Down","Right","Up","Left","sortableKeyboardCoordinates","event","context","droppableContainers","translatedRect","scrollableAncestors","includes","code","preventDefault","Object","entries","forEach","container","getViewRect","top","push","left","closestId","closestCorners","_droppableContainers$","newNode","newScrollAncestors","getScrollableAncestors","hasDifferentScrollAncestors","some","element","offset","newCoordinates","undefined"],"sources":["D:\\Proyectos\\Proceso\\CPManager\\CPManager 0.3\\frontend\\node_modules\\@dnd-kit\\sortable\\src\\utilities\\arrayMove.ts","D:\\Proyectos\\Proceso\\CPManager\\CPManager 0.3\\frontend\\node_modules\\@dnd-kit\\sortable\\src\\utilities\\getSortedRects.ts","D:\\Proyectos\\Proceso\\CPManager\\CPManager 0.3\\frontend\\node_modules\\@dnd-kit\\sortable\\src\\utilities\\isValidIndex.ts","D:\\Proyectos\\Proceso\\CPManager\\CPManager 0.3\\frontend\\node_modules\\@dnd-kit\\sortable\\src\\strategies\\horizontalListSorting.ts","D:\\Proyectos\\Proceso\\CPManager\\CPManager 0.3\\frontend\\node_modules\\@dnd-kit\\sortable\\src\\strategies\\rectSorting.ts","D:\\Proyectos\\Proceso\\CPManager\\CPManager 0.3\\frontend\\node_modules\\@dnd-kit\\sortable\\src\\strategies\\rectSwapping.ts","D:\\Proyectos\\Proceso\\CPManager\\CPManager 0.3\\frontend\\node_modules\\@dnd-kit\\sortable\\src\\strategies\\verticalListSorting.ts","D:\\Proyectos\\Proceso\\CPManager\\CPManager 0.3\\frontend\\node_modules\\@dnd-kit\\sortable\\src\\components\\SortableContext.tsx","D:\\Proyectos\\Proceso\\CPManager\\CPManager 0.3\\frontend\\node_modules\\@dnd-kit\\sortable\\src\\hooks\\defaults.ts","D:\\Proyectos\\Proceso\\CPManager\\CPManager 0.3\\frontend\\node_modules\\@dnd-kit\\sortable\\src\\hooks\\utilities\\useDerivedTransform.ts","D:\\Proyectos\\Proceso\\CPManager\\CPManager 0.3\\frontend\\node_modules\\@dnd-kit\\sortable\\src\\hooks\\useSortable.ts","D:\\Proyectos\\Proceso\\CPManager\\CPManager 0.3\\frontend\\node_modules\\@dnd-kit\\sortable\\src\\sensors\\keyboard\\sortableKeyboardCoordinates.ts"],"sourcesContent":["/**\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\n */\nexport function arrayMove<T>(array: T[], from: number, to: number): T[] {\n  const newArray = array.slice();\n  newArray.splice(\n    to < 0 ? newArray.length + to : to,\n    0,\n    newArray.splice(from, 1)[0]\n  );\n\n  return newArray;\n}\n","import type {\n  LayoutRect,\n  UniqueIdentifier,\n  UseDndContextReturnValue,\n} from '@dnd-kit/core';\n\nexport function getSortedRects(\n  items: UniqueIdentifier[],\n  layoutRects: UseDndContextReturnValue['droppableRects']\n) {\n  return items.reduce<LayoutRect[]>((accumulator, id, index) => {\n    const layoutRect = layoutRects.get(id);\n\n    if (layoutRect) {\n      accumulator[index] = layoutRect;\n    }\n\n    return accumulator;\n  }, Array(items.length));\n}\n","export function isValidIndex(index: number | null): index is number {\n  return index !== null && index >= 0;\n}\n","import type {LayoutRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const horizontalListSortingStrategy: SortingStrategy = ({\n  layoutRects,\n  activeNodeRect: fallbackActiveRect,\n  activeIndex,\n  overIndex,\n  index,\n}) => {\n  const activeNodeRect = layoutRects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  const itemGap = getItemGap(layoutRects, index, activeIndex);\n\n  if (index === activeIndex) {\n    const newIndexRect = layoutRects[overIndex];\n\n    if (!newIndexRect) {\n      return null;\n    }\n\n    return {\n      x:\n        activeIndex < overIndex\n          ? newIndexRect.offsetLeft +\n            newIndexRect.width -\n            (activeNodeRect.offsetLeft + activeNodeRect.width)\n          : newIndexRect.offsetLeft - activeNodeRect.offsetLeft,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: -activeNodeRect.width - itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: activeNodeRect.width + itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(\n  layoutRects: LayoutRect[],\n  index: number,\n  activeIndex: number\n) {\n  const currentRect = layoutRects[index];\n  const previousRect = layoutRects[index - 1];\n  const nextRect = layoutRects[index + 1];\n\n  if (!previousRect && !nextRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect\n      ? currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width)\n      : nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width);\n  }\n\n  return nextRect\n    ? nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width)\n    : currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width);\n}\n","import {arrayMove} from '../utilities';\nimport type {SortingStrategy} from '../types';\n\nexport const rectSortingStrategy: SortingStrategy = ({\n  layoutRects,\n  activeIndex,\n  overIndex,\n  index,\n}) => {\n  const newRects = arrayMove(layoutRects, overIndex, activeIndex);\n\n  const oldRect = layoutRects[index];\n  const newRect = newRects[index];\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.offsetLeft - oldRect.offsetLeft,\n    y: newRect.offsetTop - oldRect.offsetTop,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n","import type {SortingStrategy} from '../types';\n\nexport const rectSwappingStrategy: SortingStrategy = ({\n  activeIndex,\n  index,\n  layoutRects,\n  overIndex,\n}) => {\n  let oldRect;\n  let newRect;\n\n  if (index === activeIndex) {\n    oldRect = layoutRects[index];\n    newRect = layoutRects[overIndex];\n  }\n\n  if (index === overIndex) {\n    oldRect = layoutRects[index];\n    newRect = layoutRects[activeIndex];\n  }\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.offsetLeft - oldRect.offsetLeft,\n    y: newRect.offsetTop - oldRect.offsetTop,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n","import type {LayoutRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const verticalListSortingStrategy: SortingStrategy = ({\n  activeIndex,\n  activeNodeRect: fallbackActiveRect,\n  index,\n  layoutRects,\n  overIndex,\n}) => {\n  const activeNodeRect = layoutRects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  if (index === activeIndex) {\n    const overIndexRect = layoutRects[overIndex];\n\n    if (!overIndexRect) {\n      return null;\n    }\n\n    return {\n      x: 0,\n      y:\n        activeIndex < overIndex\n          ? overIndexRect.offsetTop +\n            overIndexRect.height -\n            (activeNodeRect.offsetTop + activeNodeRect.height)\n          : overIndexRect.offsetTop - activeNodeRect.offsetTop,\n      ...defaultScale,\n    };\n  }\n\n  const itemGap = getItemGap(layoutRects, index, activeIndex);\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: 0,\n      y: -activeNodeRect.height - itemGap,\n      ...defaultScale,\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: 0,\n      y: activeNodeRect.height + itemGap,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(\n  layoutRects: LayoutRect[],\n  index: number,\n  activeIndex: number\n) {\n  const currentRect = layoutRects[index];\n  const previousRect = layoutRects[index - 1];\n  const nextRect = layoutRects[index + 1];\n\n  if (!currentRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect\n      ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height)\n      : nextRect\n      ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height)\n      : 0;\n  }\n\n  return nextRect\n    ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height)\n    : previousRect\n    ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height)\n    : 0;\n}\n","import React, {MutableRefObject, useEffect, useMemo, useRef} from 'react';\nimport {useDndContext, LayoutRect, UniqueIdentifier} from '@dnd-kit/core';\nimport {useIsomorphicLayoutEffect, useUniqueId} from '@dnd-kit/utilities';\n\nimport type {SortingStrategy} from '../types';\nimport {getSortedRects} from '../utilities';\nimport {rectSortingStrategy} from '../strategies';\n\nexport interface Props {\n  children: React.ReactNode;\n  items: (UniqueIdentifier | {id: UniqueIdentifier})[];\n  strategy?: SortingStrategy;\n  id?: string;\n}\n\nconst ID_PREFIX = 'Sortable';\n\ninterface ContextDescriptor {\n  activeIndex: number;\n  containerId: string;\n  disableTransforms: boolean;\n  items: UniqueIdentifier[];\n  overIndex: number;\n  useDragOverlay: boolean;\n  sortedRects: LayoutRect[];\n  strategy: SortingStrategy;\n  wasSorting: MutableRefObject<boolean>;\n}\n\nexport const Context = React.createContext<ContextDescriptor>({\n  activeIndex: -1,\n  containerId: ID_PREFIX,\n  disableTransforms: false,\n  items: [],\n  overIndex: -1,\n  useDragOverlay: false,\n  sortedRects: [],\n  strategy: rectSortingStrategy,\n  wasSorting: {current: false},\n});\n\nexport function SortableContext({\n  children,\n  id,\n  items: userDefinedItems,\n  strategy = rectSortingStrategy,\n}: Props) {\n  const {\n    active,\n    overlayNode,\n    droppableRects,\n    over,\n    recomputeLayouts,\n    willRecomputeLayouts,\n  } = useDndContext();\n  const containerId = useUniqueId(ID_PREFIX, id);\n  const useDragOverlay = Boolean(overlayNode.rect !== null);\n  const items = useMemo(\n    () =>\n      userDefinedItems.map((item) =>\n        typeof item === 'string' ? item : item.id\n      ),\n    [userDefinedItems]\n  );\n  const activeIndex = active ? items.indexOf(active.id) : -1;\n  const isSorting = activeIndex !== -1;\n  const wasSorting = useRef(isSorting);\n  const overIndex = over ? items.indexOf(over.id) : -1;\n  const previousItemsRef = useRef(items);\n  const sortedRects = getSortedRects(items, droppableRects);\n  const itemsHaveChanged = !isEqual(items, previousItemsRef.current);\n  const disableTransforms =\n    (overIndex !== -1 && activeIndex === -1) || itemsHaveChanged;\n\n  useIsomorphicLayoutEffect(() => {\n    if (itemsHaveChanged && isSorting && !willRecomputeLayouts) {\n      // To-do: Add partial recompution of only subset of rects\n      recomputeLayouts();\n    }\n  }, [itemsHaveChanged, isSorting, recomputeLayouts, willRecomputeLayouts]);\n\n  useEffect(() => {\n    previousItemsRef.current = items;\n  }, [items]);\n\n  useEffect(() => {\n    requestAnimationFrame(() => {\n      wasSorting.current = isSorting;\n    });\n  }, [isSorting]);\n\n  const contextValue = useMemo(\n    (): ContextDescriptor => ({\n      activeIndex,\n      containerId,\n      disableTransforms,\n      items,\n      overIndex,\n      useDragOverlay,\n      sortedRects,\n      strategy,\n      wasSorting,\n    }),\n    [\n      activeIndex,\n      containerId,\n      disableTransforms,\n      items,\n      overIndex,\n      sortedRects,\n      useDragOverlay,\n      strategy,\n      wasSorting,\n    ]\n  );\n\n  return <Context.Provider value={contextValue}>{children}</Context.Provider>;\n}\n\nfunction isEqual(arr1: string[], arr2: string[]) {\n  return arr1.join() === arr2.join();\n}\n","import {CSS} from '@dnd-kit/utilities';\n\nimport type {AnimateLayoutChanges, SortableTransition} from './types';\n\nexport const defaultAnimateLayoutChanges: AnimateLayoutChanges = ({\n  isSorting,\n  index,\n  newIndex,\n  transition,\n}) => {\n  if (!transition) {\n    return false;\n  }\n\n  if (isSorting) {\n    return true;\n  }\n\n  return newIndex !== index;\n};\n\nexport const defaultTransition: SortableTransition = {\n  duration: 200,\n  easing: 'ease',\n};\n\nexport const transitionProperty = 'transform';\n\nexport const disabledTransition = CSS.Transition.toString({\n  property: transitionProperty,\n  duration: 0,\n  easing: 'linear',\n});\n\nexport const defaultAttributes = {\n  roleDescription: 'sortable',\n};\n","import {useEffect, useRef, useState} from 'react';\nimport {getBoundingClientRect, LayoutRect} from '@dnd-kit/core';\nimport type {Transform} from '@dnd-kit/utilities';\n\ninterface Arguments {\n  rect: React.MutableRefObject<LayoutRect | null>;\n  disabled: boolean;\n  index: number;\n  node: React.MutableRefObject<HTMLElement | null>;\n}\n\n/*\n * When the index of an item changes while sorting,\n * we need to temporarily disable the transforms\n */\nexport function useDerivedTransform({rect, disabled, index, node}: Arguments) {\n  const [derivedTransform, setDerivedtransform] = useState<Transform | null>(\n    null\n  );\n  const prevIndex = useRef(index);\n\n  useEffect(() => {\n    if (!disabled && index !== prevIndex.current && node.current) {\n      const initial = rect.current;\n\n      if (initial) {\n        const current = getBoundingClientRect(node.current);\n        const delta = {\n          x: initial.offsetLeft - current.offsetLeft,\n          y: initial.offsetTop - current.offsetTop,\n          scaleX: initial.width / current.width,\n          scaleY: initial.height / current.height,\n        };\n\n        if (delta.x || delta.y) {\n          setDerivedtransform(delta);\n        }\n      }\n    }\n\n    if (index !== prevIndex.current) {\n      prevIndex.current = index;\n    }\n  }, [disabled, index, node, rect]);\n\n  useEffect(() => {\n    if (derivedTransform) {\n      requestAnimationFrame(() => {\n        setDerivedtransform(null);\n      });\n    }\n  }, [derivedTransform]);\n\n  return derivedTransform;\n}\n","import {useContext, useEffect, useMemo, useRef} from 'react';\nimport {useDraggable, useDroppable, UseDraggableArguments} from '@dnd-kit/core';\nimport {CSS, useCombinedRefs} from '@dnd-kit/utilities';\n\nimport {Context} from '../components';\nimport type {SortingStrategy} from '../types';\nimport {arrayMove, isValidIndex} from '../utilities';\nimport {\n  defaultAnimateLayoutChanges,\n  defaultAttributes,\n  defaultTransition,\n  disabledTransition,\n  transitionProperty,\n} from './defaults';\nimport type {AnimateLayoutChanges, SortableTransition} from './types';\nimport {useDerivedTransform} from './utilities';\n\nexport interface Arguments extends UseDraggableArguments {\n  animateLayoutChanges?: AnimateLayoutChanges;\n  strategy?: SortingStrategy;\n  transition?: SortableTransition | null;\n}\n\nexport function useSortable({\n  animateLayoutChanges = defaultAnimateLayoutChanges,\n  attributes: userDefinedAttributes,\n  disabled,\n  data: customData,\n  id,\n  strategy: localStrategy,\n  transition = defaultTransition,\n}: Arguments) {\n  const {\n    items,\n    containerId,\n    activeIndex,\n    disableTransforms,\n    sortedRects,\n    overIndex,\n    useDragOverlay,\n    strategy: globalStrategy,\n    wasSorting,\n  } = useContext(Context);\n  const index = items.indexOf(id);\n  const data = useMemo(\n    () => ({sortable: {containerId, index, items}, ...customData}),\n    [containerId, customData, index, items]\n  );\n  const {rect, node, setNodeRef: setDroppableNodeRef} = useDroppable({\n    id,\n    data,\n  });\n  const {\n    active,\n    activeNodeRect,\n    activatorEvent,\n    attributes,\n    setNodeRef: setDraggableNodeRef,\n    listeners,\n    isDragging,\n    over,\n    transform,\n  } = useDraggable({\n    id,\n    data,\n    attributes: {\n      ...defaultAttributes,\n      ...userDefinedAttributes,\n    },\n    disabled,\n  });\n  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);\n  const isSorting = Boolean(active);\n  const displaceItem =\n    isSorting &&\n    wasSorting.current &&\n    !disableTransforms &&\n    isValidIndex(activeIndex) &&\n    isValidIndex(overIndex);\n  const shouldDisplaceDragSource = !useDragOverlay && isDragging;\n  const dragSourceDisplacement =\n    shouldDisplaceDragSource && displaceItem ? transform : null;\n  const strategy = localStrategy ?? globalStrategy;\n  const finalTransform = displaceItem\n    ? dragSourceDisplacement ??\n      strategy({\n        layoutRects: sortedRects,\n        activeNodeRect,\n        activeIndex,\n        overIndex,\n        index,\n      })\n    : null;\n  const newIndex =\n    isValidIndex(activeIndex) && isValidIndex(overIndex)\n      ? arrayMove(items, activeIndex, overIndex).indexOf(id)\n      : index;\n  const prevNewIndex = useRef(newIndex);\n  const shouldAnimateLayoutChanges = animateLayoutChanges({\n    active,\n    isDragging,\n    isSorting,\n    id,\n    index,\n    items,\n    newIndex: prevNewIndex.current,\n    transition,\n    wasSorting: wasSorting.current,\n  });\n  const derivedTransform = useDerivedTransform({\n    disabled: !shouldAnimateLayoutChanges,\n    index,\n    node,\n    rect,\n  });\n\n  useEffect(() => {\n    if (isSorting) {\n      prevNewIndex.current = newIndex;\n    }\n  }, [isSorting, newIndex]);\n\n  return {\n    active,\n    attributes,\n    activatorEvent,\n    rect,\n    index,\n    isSorting,\n    isDragging,\n    listeners,\n    node,\n    overIndex,\n    over,\n    setNodeRef,\n    setDroppableNodeRef,\n    setDraggableNodeRef,\n    transform: derivedTransform ?? finalTransform,\n    transition: getTransition(),\n  };\n\n  function getTransition() {\n    if (derivedTransform) {\n      // Temporarily disable transitions for a single frame to set up derived transforms\n      return disabledTransition;\n    }\n\n    if (shouldDisplaceDragSource || !transition) {\n      return null;\n    }\n\n    if (isSorting || shouldAnimateLayoutChanges) {\n      return CSS.Transition.toString({\n        ...transition,\n        property: transitionProperty,\n      });\n    }\n\n    return null;\n  }\n}\n","import {\n  closestCorners,\n  getViewRect,\n  getScrollableAncestors,\n  KeyboardCode,\n  RectEntry,\n  KeyboardCoordinateGetter,\n} from '@dnd-kit/core';\n\nconst directions: string[] = [\n  KeyboardCode.Down,\n  KeyboardCode.Right,\n  KeyboardCode.Up,\n  KeyboardCode.Left,\n];\n\nexport const sortableKeyboardCoordinates: KeyboardCoordinateGetter = (\n  event,\n  {context: {droppableContainers, translatedRect, scrollableAncestors}}\n) => {\n  if (directions.includes(event.code)) {\n    event.preventDefault();\n\n    if (!translatedRect) {\n      return;\n    }\n\n    const layoutRects: RectEntry[] = [];\n\n    Object.entries(droppableContainers).forEach(([id, container]) => {\n      if (container?.disabled) {\n        return;\n      }\n\n      const node = container?.node.current;\n\n      if (!node) {\n        return;\n      }\n\n      const rect = getViewRect(node);\n\n      switch (event.code) {\n        case KeyboardCode.Down:\n          if (translatedRect.top + translatedRect.height <= rect.top) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n        case KeyboardCode.Up:\n          if (translatedRect.top >= rect.top + rect.height) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n        case KeyboardCode.Left:\n          if (translatedRect.left >= rect.left + rect.width) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n        case KeyboardCode.Right:\n          if (translatedRect.left + translatedRect.width <= rect.left) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n      }\n    });\n\n    const closestId = closestCorners(layoutRects, translatedRect);\n\n    if (closestId) {\n      const newNode = droppableContainers[closestId]?.node.current;\n\n      if (newNode) {\n        const newScrollAncestors = getScrollableAncestors(newNode);\n        const hasDifferentScrollAncestors = newScrollAncestors.some(\n          (element, index) => scrollableAncestors[index] !== element\n        );\n        const newRect = getViewRect(newNode);\n        const offset = hasDifferentScrollAncestors\n          ? {\n              x: 0,\n              y: 0,\n            }\n          : {\n              x: translatedRect.width - newRect.width,\n              y: translatedRect.height - newRect.height,\n            };\n        const newCoordinates = {\n          x: newRect.left - offset.x,\n          y: newRect.top - offset.y,\n        };\n\n        return newCoordinates;\n      }\n    }\n  }\n\n  return undefined;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}